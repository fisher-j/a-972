```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```


### Predicting missing heights

It might be important to fill in missing heights (especially for dominant trees) in 2018. First I'll explore a simple linear relationship between dbh and height increment. I'm only looking at live, unbroken redwood and Douglas-fir.

```{r}

test_d <- d_l %>%
  # add increment data
  group_by(tree_id) %>%
  mutate(
    ht_inc_2 = nth(lead(ht) - ht, 3, order_by = year) / 5,
    ht_inc_1 = nth(lead(ht) - ht, 2, order_by = year) / 5,
    ht_13 = nth(ht, 3, order_by = year)) %>%
  # only use unbroken live sese or psme from 2018
  filter(
    spp %in% c("SESE3", "PSMEM"),
    year == "18",
    status == 1,
    !get_cond(2, 3)
  ) %>%
  ungroup()
  
# fit model to each group to generate lables for plot
plot_groups <- function(
  group = treatment,
  response = ht_inc_2,
  predictor = dbh,
  by_spp = TRUE,
  title,
  pred = FALSE
  ) {
  palette("Tableau 10")
  x <- substitute(predictor)
  y <- substitute(response)
  form <- formula(bquote(.(y) ~ .(x)))
  if (by_spp) {
    dat <- group_by(test_d, group = {{group}}, spp)
  } else {
    dat <- group_by(test_d, group = {{group}})
  }
  mytext <- dat %>%
    summarize(lm_eqn(lm(form, data = cur_data())))
  if (by_spp) {
    mytext <- pivot_longer(mytext, !c(group, spp)) %>%
    arrange(group, name) %>%
    mutate(
      x = npc(dat[[x]], c(0, 0, .7, .7, .7, .7)),
      y = npc(dat[[y]], c(1.1, 1, .1, 0, 1.1, 1))
    )
  } else {
    mytext <- pivot_longer(mytext, !c(group)) %>%
    arrange(group, name) %>%
    group_by(group) %>%
    mutate(
      x = npc(dat[[x]], c(0, .7, .7)),
      y = npc(dat[[y]], c(1.1,.1,1.1))
    )
  }
  # Plot based on specified group and species (if indicated)
  p <- if (by_spp) {
    ggplot(
      dat,
      aes(x = {{predictor}},
      y = {{response}},
      fill = spp,
      color = spp)
    )
  } else {
    ggplot(dat, aes(x = {{predictor}}, y = {{response}}))
  }
  print(p +
      geom_point(size = 1.3, shape = 16, alpha = .6) +
      geom_smooth(method = "lm", alpha = .25) +
      facet_wrap(~ group) +
      geom_text(
        data = mytext,
        aes(x = x, y = y, label = value, hjust = 0),
        parse = TRUE,
        family = "mono",
        fontface = "bold"
      ) +
      labs(title = title) +
      theme_bw() +
      scale_color_manual(
        values = palette(),
        aesthetics = c("color", "fill")) +
      guides(fill = guide_legend(override.aes = aes(label = ""))) +
      if(pred == TRUE) {
        geom_point(data = miss, aes(color = spp), shape = 16)
      }
  )
}
```

Out of these models, the H40, H80 and L80 have a p < 0.05. In none of them is there a significant difference in slope (between species). Constants are significantly different for H40, L80.

```{r, fig.height=7.5, fig.width=10.5, warning=FALSE}
plot_groups(title = "Height increment vs dbh")
```

```{r}
library(broom)

get_model_stats <- function(formula, grouping) {
  test_d %>% 
    nest_by(group = {{grouping}}) %>%
    mutate(
      mod = list(lm(formula, data = data)),
      summary = list(tidy(mod)),
      pf = pf(
        summary(mod)$fstatistic[1],
        summary(mod)$fstatistic[2],
        summary(mod)$fstatistic[3],
        lower.tail = FALSE
      )
    ) %>%
    unnest(summary) %>%
    select(-c(data, mod))
}
```

```{r}
stat <- get_model_stats(formula = ht_inc_2 ~ dbh * spp, grouping = treatment)
stat %>%
  color_groups() %>%
  row_spec(which(stat$p.value < .05), background = "MistyRose")


stat <- get_model_stats(formula = ht_inc_2 ~ dbh + spp, grouping = treatment)
stat %>%
  color_groups() %>%
  row_spec(which(stat$p.value < .05), background = "MistyRose")
```

Now I'm combining treatments so we only have a C, H, and L. Again slopes are not significantly different and neither are constants between species.

```{r, fig.height=4, fig.width=10.5, warning=FALSE}
# Now I'll combine treatments so we just have a H, L and C
plot_groups(str_extract(treatment, "C|H|L"), title = "Height increment vs dbh")
```

```{r}
# do ancova, look at interaction first and then see if 
# y-intercepts are any different between models.

stat <- get_model_stats(
  formula = ht_inc_2 ~ dbh * spp,
  grouping = str_extract(treatment, "C|L|H"))
stat %>%
  color_groups() %>%
  row_spec(which(stat$p.value < .05), background = "MistyRose")

stat <- get_model_stats(
  formula = ht_inc_2 ~ dbh + spp,
  grouping = str_extract(treatment, "C|L|H"))
stat %>%
  color_groups() %>%
  row_spec(which(stat$p.value < .05), background = "MistyRose")
```

I'll look at what happens if I group by treatment intensity instead. Again, this does not seem to reveal any especially significant 

```{r, fig.height=4, fig.width=10.5, warning=FALSE}
# for comparison I'll combine treatment intensities instead
plot_groups(str_extract(treatment, "C|40|80"), title = "Height increment vs dbh")
```

Perhaps a height model that includes more predictors would reveal a difference in response between treatments, our current models are not capturing much variance. I had the thought that we already have height data for our trees, shouldn't that be a pretty good predictor of height in the next period? For that matter, I can also use height_inc from period 1 and current dbh as well and vary these all by treatment.

I'll start with a full model for height and then remove variables (or interactions of variables) based on AIC.

```{r}
 mod1 <- lm(ht ~ (ht_13 + ht_inc_1 + dbh) * treatment * spp, data = test_d)
summary(mod1)
```


It turns out the varying first period increment by spp and treatment lowers AIC, so I'll pull it out of the interaction. Pulling out dbh or ht_13 don't appear to result in any significant improvement in AIC.

```{r}
drop1(mod1)
mod2 <- lm(ht ~ (ht_13 + dbh) * treatment * spp  + ht_inc_1, data = test_d)
summary(mod2)
drop1(mod2)
miss <- test_d %>% filter(is.na(ht), across(c(dbh, ht_13, ht_inc_1), ~ !is.na(.)))
miss$ht <- predict(mod2, miss)

plot(
  test_d$dbh,
  test_d$ht,
  main = paste("Predicted and recorded heights for 2018", format(formula(mod2)), sep = "\n"),
  xlab = "dbh",
  ylab = "Height"
)
points(miss$dbh, miss$ht, col = "indianred", pch = 16, cex = .8)

```

Testing another model. We have previous heights and previous increments,  If I was going to predict heights by hand, that's how I would do it.

```{r}
mod3 <- lm(ht ~ ht_13*treatment*spp, data = test_d)
summary(mod3)
```

Here I'll show the plots of how 2018 height varies with each of the predictors, starting with dbh, which is highly correlated with heights. There is a clear difference between the constants for redwood and douglas-fir. While most of the slopes seem parallel, Treatment H40 seems different and if we look at just that treatment, the interaction is significant.

```{r, fig.height=7.5, fig.width=10.5}
plot_groups(response = ht, predictor = dbh, title = "Height vs dbh")
```

It would seem that when included in the entire model, the effect adding a dummy variable for the interaction between spp, dbh and treatment is not quite significant.

Next I'll plot first period ht increment, this was included in the model but without any interactions, so the first plot shows its effect without any groupings. The second plot shows its relationship with spp and treatment groups, this variation is not included in the model.

```{r, fig.height=4, fig.width=4}
plot_groups(
  group = TRUE,
  response = ht,
  predictor = ht_inc_1, title = "Height vs first period ht increment",
  by_spp = FALSE
)
```

```{r, fig.width=10, fig.height=6.5}
plot_groups(
  response = ht,
  predictor = ht_inc_1,
  title = "Height vs first period ht increment\nwith interactions"
)
```

Finally, here is a plot of 2013 ht and 2018 heights. Because the model currently has this variable interacting with treatment and species, this is a more accurate representation of its effect (in the model). Its funny though, if I were to guess, it seems like this predictor is the most consistent across species and treatments.

```{r, fig.height=7.5, fig.width=10.5}

plot_groups(response = ht, predictor = ht_13, title = "Height vs 2013 height")

```

This is what it looks like if I group 2018 heights into thinned and unthinned groups.

```{r}
test_d2 <- mutate(
  test_d, treatment = if_else(
    str_detect(treatment, "C"),
    "unthinned",
    "thinned"
    )
  )

mod4 <- lm(ht ~ 0 + ht_13:spp:treatment, data = test_d2)
summary(mod4)

plot_groups(
  predictor = ht_13,
  response = ht,
  group = if_else(str_detect(treatment, "C"), "unthinned", "thinned"),
  title = "Height increment vs dbh\nthinned vs unthinned"
)
```

# Non-linear height-dbh model

What if I just use a height/dbh model suggested by Eng, Hanus et al. and Curtis. And what if I combine 2013 and 2018 datasets? This contributes a lot more data. Maybe averaging across all treatments represents a conservative strategy in that any significant differences would likely not be due to the prediction.

```{r}
palette("Set 2")
d <- p_h %>% filter(year %in% c("13", "18"), status == 1, !get_cond(2, 3), spp %in% c("SESE3", "PSMEM"))
d1 <- d %>% filter(spp == "SESE3")
d2 <- d %>% filter(spp == "PSMEM")

ht_mod1 <- nls(
  ht ~ 1.3 + exp(b0 + b1 * I(dbh^b2)),
  data = d1, 
  start = list(b0 = 5, b1 = -5, b2 = -.5)
)
ht_mod2 <- nls(ht ~ 1.3 + exp(b0 + b1 * I(dbh^b2)),
  data = d2,
  start = list(b0 = 5, b1 = -5, b2 = -.5)
)

nls_plot <- function(color = spp, facet = NULL, title, col = NULL) {
  palette("Tableau 10")
  if (is.null(col)) col <- 1:length(palette())
  facet <- enquo(facet)
  aesth <- aes(dbh, ht, color = {{color}})
  p <- ggplot(arrange(d, spp), aesth) +
  geom_jitter(height = .5, width = .5, alpha = .3) +
  geom_smooth(
    method = "nls",
    formula = y ~ 1.3 + exp(b0 + b1 * I(x^b2)),
    method.args = list(start = list(b0 = 5, b1 = -5, b2 = -.5)),
    se = FALSE,
    size = 1.3
    ) +
  scale_color_manual(values = palette()[col]) +
  labs(title = title) +
  if(!is.null(facet)) facet_wrap(vars(!!facet))
  print(p)
}
```

```{r, fig.height=8, fig.width=8}
title <- "Non linear model by species for 2013 and 2018\nAll treatments"
nls_plot(title = title)
title <- "difference in fit between 2013 and 2018"
nls_plot(color = year, facet = spp, title = title, col = c(9, 7))
title <- "Difference in fit between treatments\nyears 2013 and 2018"
nls_plot(facet = treatment, color = spp, title = title)
title <- "Differences between treatments\nyears 2013 and 2018"
nls_plot(color = treatment, facet = spp, title = title)
```

