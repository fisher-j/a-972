---
title: "Modeling BA increment"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = TRUE)
```

```{r}
library(lme4)
palette("Tableau 10")
library(patchwork)
```

# Introduction

Basal area increment is a key feature for analysis. Dbh data is available for almost all trees in both periods, it is more precise and diameter growth (as opposed to height growth) is expected to have a strong response to thinning treatments.

# Define trees of interest

For basal area increment, I will include all live trees without broken or dead tops. I am including trees identified as leaning, these should mostly have good growth and accurate measurements. I am excluding bear damaged trees. Increment for a period will be assigned to the beginning of period observation. This means I will want to exclude observations in which a tree is damaged by bear in this or a subsequent observation.

I am including trees with dead or broken tops when they didn't lose more than 25% of their initial height. This is only about 25 trees. There are many more with broken tops that are missing heights, but histograms of the diameter increment of these suggest that they are not that different from the set of trees that have heights.

```{r}

filter(test_d, !is.na(ht_inc1)) %>%
  ggplot(aes(x = d_inc1, y = stat(count / sum(count)) )) +
  geom_histogram(aes(fill = "heights available"), alpha = 0.5) +
  geom_histogram(
    data = filter(test_d, is.na(ht_inc1)),
    aes(fill = "heights NA"), alpha = 0.5) +
  # geom_histogram(
  #   data = filter(test_d, !get_cond(2, 3), !lead(get_cond(2, 3))),
  #   aes(fill = "unbroken"), alpha = 0.5)
  labs(x = "diameter increment", y = "proportion of observations")

```

I'm also filtering out observations that don't have crown ratio, this loses 1 redwood in the L40 treatment, dropping observations from 10 to 9, as well as losing 10 redwood in H80, but this is less of a problem. If CR proves not useful, I will remove this constraint.

I'm also removing trees with less than -0.2 (negative) diameter increment

```{r}



test_d <- d_l %>%
  group_by(tree_id) %>%
  # only use unbroken live sese or psme from 2018
  filter(
    d_inc1 >= -0.2,
    # remove trees that lost more than 25% of height
    is.na(ht_inc1) | (ht_inc1 * 5 / ht) > -1/4,
    spp %in% c("SESE3", "PSMEM"),
    year %in% c("08", "13"),
    # Live and doesn't die by next period
    status == 1 & lead(status == 1),
    !is.na(dbh),
    # bear free this period and next
    !bear & lead(!bear),
    !is.na(cr)
  ) %>%
  mutate(
    treat_method = str_extract(treatment, "C|H|L"),
    treat_density = str_extract(treatment, "C|40|80"),
    treat_status = if_else(str_detect(treatment, "C"), "unthinned", "thinned"),
    year = as.character(year)
  ) %>%
  select(-c(h_dist, azi, rot, cc, x, y, live)) %>%
  # add a scaled ba_inc1 variable for convenience
  ungroup() %>%
  mutate(ba_inc_scaled = (ba_inc1 - min(ba_inc1) + 0.1)) 

# Alter one outlier record in year 2013 by using data from previous year
big_tree <- "4H80.4019"
replacement_data <- filter(test_d, tree_id == big_tree, year == "13") %>%
  transmute(
    dbh = dbh,
    d_inc1 = d_inc2,
    ba = ba,
    ba_inc1 = ba_inc2,
  )
bad_rec <- with(test_d, which(tree_id == big_tree & year == "13"))
test_d[bad_rec, names(replacement_data)] <- replacement_data

display_vars <- function(x) {
  select(x, c(tree_id, year, dbh, ht_p, bear, cr, notes, cond, d_inc1, ba_inc1))
}
```

Number of redwoods and Douglas fir trees in each plot and each treatment. I have a little problem with sample size when it comes to redwood. Some plots have zero or one observation. It seems like bears took a tole on the 

```{r}

test_d %>%
  group_by(plot) %>%
  mutate(n_sese = sum(spp == "SESE3")) %>%
  group_by(treatment) %>%
  mutate(n_sese_treat = sum(spp == "SESE3")) %>%
  arrange(desc(n_sese_treat), desc(n_sese)) %>%
  ggplot(aes(fct_inorder(plot))) +
    geom_bar(aes(fill = spp)) +
    geom_text(
      aes(label = after_stat(count), group = spp),
      stat = "count",
      position = position_stack(vjust = .5)
    ) +
    facet_wrap(~year) +
    coord_flip() +
    scale_fill_manual(values = palette()) +
    labs(x = "Plots, nested within treatments")

test_d %>%
  group_by(plot) %>%
  mutate(n_sese = sum(spp == "SESE3")) %>%
  group_by(treatment) %>%
  mutate(n_sese_treat = sum(spp == "SESE3")) %>%
  arrange(desc(n_sese_treat), desc(n_sese)) %>%
  ggplot(aes(fct_reorder(treatment, n_sese, .desc = TRUE))) +
    geom_bar(aes(fill = spp)) +
    geom_text(
      aes(label = after_stat(count),
      group = spp),
      stat = "count",
      position = position_stack(vjust = .5)
    ) +
    facet_wrap(~year) +
    coord_flip() +
    scale_fill_manual(values = palette())

```

# Data exploration

## Outliers

Here I'm looking for any outliers in basal area increment, or extreme changes. There are definitely basal area outliers some of the most extreme can be explained by having bear damage, but on average, bear-damaged trees have diameter increments almost double those of non-bear-damaged. It is unclear whether this is due to loose bark, or the fact that these trees tend to be faster growing. This question might need further investigation. Following Dagley et. al 2018, I will remove bear damaged trees from analysis. Another option could be including bear damage as a covariate.

```{r}

# outliers defined as 1.5 times above or below IQR
test_d %>%
  filter(
    out(ba_inc1)
  ) %>%
  group_by(tree_id) %>%
  arrange(ba_inc1) %>%
  display_vars %>%
  color_groups()

# dot plot of outliers
test_d %>%
  ggplot(aes(x = ba_inc1, y = fct_reorder(tree_id, d_inc1))) +
    geom_line(aes(group = tree_id), alpha = .3) +
    geom_point(aes(color = year), alpha = .5) +
    scale_y_discrete(breaks = NULL, expand = expansion(add = 10)) +
    scale_color_manual(values = palette()) +
    guides(color = guide_legend(override.aes = list(shape = c(19, 19)))) +
    labs(
      x = "BA increment (cm)",
      y = "tree id (sorted by diameter increment)"
    )

```

While the above seems to show an extreme outlier in terms of ba_inc1, if we look at the full dataset, including bear damaged trees, and plot *diameter* increment, instead of basal area, then the outlier seems less extreme.

*Note, I've edited the outlier so its basal area increment in the second period is the same as its first, so it no longer shows up on this graph*

```{r}

d_l %>%
  filter(year %in% c("08", "13"), live) %>%
  ggplot(aes(x = d_inc1, y = fct_reorder(tree_id, d_inc1))) +
    geom_line(aes(group = tree_id), alpha = .3) +
    geom_point(aes(color = year), alpha = .5) +
    scale_y_discrete(breaks = NULL, expand = expansion(add = 10)) +
    scale_color_manual(values = palette()) +
    guides(color = guide_legend(override.aes = list(shape = c(19, 19)))) +
    labs(
      x = "diameter increment (cm)",
      y = "tree id ALL TREES (sorted by diameter increment)"
    )

```

## Negative values

There are a total of 57 observations with negative increments. These could be dropped, but they likely represent measurement error which likely went both ways. Diameter *decrement* ranges from .1 to 1 inch. I may want to remove these later.

```{r}
test_d %>% 
filter(ba_inc1 < 0) %>%
arrange(d_inc1) %>% print(n=50)
pull(d_inc1) %>% 
summary()
```

## Crown ratio

I'm going to test cr in the model, it doesn't lose too many more observations by including it, if it doesn't seem to be worth it, I might include those few observations back in the data.

```{r}

test_d %>%
  group_by(treatment, year) %>%
  summarize(
    "missing height" = sum(is.na(ht_p)),
    "missing cr" = sum(is.na(cr))
  )

test_d %>%
  ggplot(aes(x = cr, fill = spp)) +
    geom_bar() +
    facet_wrap(~ year)
```

## Plotting data

First I'll look at distributions of the response:

```{r}

hist(test_d$ba_inc1, main = "Basal area increment")
hist(log(test_d$ba_inc1 + 18), main = "Log of basal area increment + constant")
with(test_d, plot(dbh, ba_inc1))

hist(test_d$dbh, main = "DBHt")
hist(log(test_d$dbh + 18), main = "Log of DBH")

```

relationship of ba_inc1 with dbh by species and year is not exactly linear, I will use a transformation or a GLM with a different distribution.

```{r}

test_d %>%
  ggplot(aes(x = dbh, y = ba_inc1, color = spp)) +
  geom_point(alpha = 0.3) +
  facet_wrap(~ year) +
  scale_color_manual(values = palette())

test_d %>%
  ggplot(aes(x = (dbh), y = log(ba_inc1 + scale_val), color = spp)) +
  geom_point(alpha = 0.3) +
  facet_wrap(~ year) +
  scale_color_manual(values = palette())

test_d %>%
  ggplot(aes(x = log(dbh), y = (ba_inc1), color = spp)) +
  geom_point(alpha = 0.3) +
  facet_wrap(~ year) +
  scale_color_manual(values = palette())

test_d %>%
  ggplot(aes(x = log(dbh), y = log(ba_inc1 + scale_val), color = spp)) +
  geom_point(alpha = 0.3) +
  facet_wrap(~ year) +
  scale_color_manual(values = palette())

```

does crown ratio have a relationship with diameter increment?

```{r}
library(ggpubr)

test_d %>%
  ggplot(aes(cr, d_inc1), color = spp) +
  geom_point() +
  geom_smooth(method = "lm") +
  stat_cor()

```

## Evidence that my response is not normally distributed?

looking at 2-inch diameter classes, it would seem that ba_inc is not normally distributed by dbh.

```{r}
d_l %>%
  filter(live, !bear, year %in% c("08", "13")) %>%
  mutate(dbh_cut = cut_interval(dbh, length = 2)) %>%
  ggplot(aes(1/(ba_inc1))) +
    geom_histogram() +
    facet_wrap(~ dbh_cut, scales = "free")
```

## Change in ba-inc over years at tree level

We can see that in the control, relatively few redwood decreased in size. Few trees over all decreased in size in the H40 and L40 treatments, In the L80 treatment, few redwoods decreased in size, and many fir did. In the intense treatments (40's) majority of trees increased in growth rate. Overall, there seems to be a species * treatment * year interaction

```{r, fig.height=8, fig.width=9}
test_d %>%
  filter(ba_inc1 < 150) %>%
  group_by(tree_id) %>%
  mutate(increase = any(ba_inc1 > lag(ba_inc1), na.rm = TRUE)) %>%
  ggplot(aes(year, ba_inc1, color = increase, group = tree_id)) +
    geom_line(size = .8, alpha = .7) +
    facet_wrap(~ treatment + spp) +
    scale_x_discrete(expand = expansion(mult = 0.1)) +
    scale_y_continuous(expand = expansion(mult = 0.01)) 
```

And what about at the plot level, can I discern any interactions between species, year and plot?

```{r, fig.height=6, fig.width=10}
plot_bainc_change <- function(treatment) {
  test_d %>%
    filter(ba_inc1 < 150, treatment == {{treatment}}) %>%
    group_by(tree_id) %>%
    mutate(increase = any(ba_inc1 > lag(ba_inc1), na.rm = TRUE)) %>%
    ggplot(aes(year, ba_inc1, color = increase, group = tree_id)) +
      theme(legend.position = "bottom") +
      geom_line(size = .8, alpha = .7) +
      facet_grid(rows = vars(spp), cols = vars(plot)) +
      scale_x_discrete(expand = expansion(mult = 0.1)) +
      scale_y_continuous(expand = expansion(mult = 0.01))
}

plot_bainc_change("C")
plot_bainc_change("H40")
plot_bainc_change("L40")
plot_bainc_change("H80")
plot_bainc_change("L80")

```

# Modeling

Is year significant for basal area increment? T-Test? It looks like year is close to significant for the higher intensity treatments.

```{r}

test_d %>%
  group_by(treatment) %>%
  select(year, ba_inc1) %>%
  summarize(as.data.frame(t.test(ba_inc1 ~ year)[c("estimate", "parameter", "p.value")]))

```

## Basic model forms

Basal area increment is expected to vary by dbh and crown ratio. We hope to see a treatment effect. Because of the interaction with year, I will try to model for the most recent increment period only.

```
model a: scaled_ba_inc1 = exp((dbh) * treatment * spp), gamma distribution
model b: scaled_ba_inc1 = exp((dbh) * treatment * spp), gaussian distribution
model c: log(ba_inc1) = dbh * treatment * spp 
model d: ba_inc1 = (log(dbh) + dbh) * treatment * spp
```
The scaling value was computed as `abs(min(ba_inc1)) + 0.1`


```{r, fig.height=7, fig.width=10}

scale_val <- with(test_d, abs(min(ba_inc1)) + 0.1)

m6a <- glm(
  I(ba_inc1 + scale_val) ~ dbh * treatment * spp,
  family = Gamma(link = "log"),
  data = test_d
)

m6b <- glm(
  I(ba_inc1 + scale_val) ~ dbh * treatment * spp,
  family = gaussian(link = "log"),
  data = test_d
)


m6c <- lm(log(ba_inc1 + scale_val) ~ dbh * treatment * spp, data = test_d)

m6e <- lm(log(ba_inc1 + scale_val) ~ log(dbh) * treatment * spp, data = test_d)

m6d <- lm(ba_inc1 ~ log(dbh) + dbh * treatment * spp, data = test_d)


```

I don't think that the model with transformed response is comparable but the other three I think are. The gamma glm with log link and extra predictors has the lowest AIC. I will use it moving forward.

```{r}
AICc(m6a, m6b, m6c, m6d, m6e)
```

```{r}

test_d %>%
  mutate(
    as_tibble(predict(m6a, newdata = cur_data_all(), se.fit = TRUE, type = "response")[1:2]),
    upr = fit + 2 * se.fit,
    lwr = fit - 2 * se.fit
    ) %>%
  ggplot(aes(y = ba_inc1, x = dbh, color = spp)) +
    geom_point(alpha = 0.3) +
    geom_line(aes(y = fit - scale_val), size = 1) +
    geom_ribbon(
      aes(ymin = lwr - scale_val, ymax = upr - scale_val, group = spp),
      alpha = 0.2,
      color = NA
    ) +
    facet_wrap(vars(treatment)) +
    scale_color_manual(values = palette()) +
    labs(title = "gamma GLM with log link")

test_d %>%
  ggplot(aes(x = dbh, y = ba_inc1 + scale_val, color = spp)) +
    geom_point(alpha = .2) +
    facet_wrap(vars(treatment)) +
    geom_smooth(
      method = "glm",
      formula = y ~ x,
      method.args = list(family = gaussian(link = "log"))
    ) +
    scale_color_manual(values = palette()) +
    labs(title = "Gaussian glm wih log link")

test_d %>%
  ggplot(aes(x = dbh, y = log(ba_inc1 + scale_val), color = spp)) +
    geom_point(alpha = .2) +
    facet_wrap(vars(treatment)) +
    geom_smooth(method = "lm", formula = y ~ x) +
    scale_color_manual(values = palette()) +
    labs(title = "Linear model, log-transformed")

test_d %>%
  ggplot(aes(x = log(dbh), y = log(ba_inc1 + scale_val), color = spp)) +
    geom_point(alpha = .2) +
    facet_wrap(vars(treatment)) +
    geom_smooth(method = "lm", formula = y ~ x) +
    scale_color_manual(values = palette()) +
    labs(title = "Linear model, log-log-transformed")


test_d %>%
  ggplot(aes(x = dbh, y = ba_inc1, color = spp)) +
    geom_point(aes(), alpha = .2) +
    geom_smooth(method = "lm", formula = y ~ log(x) + x) +
    facet_wrap(vars(treatment)) +
    scale_color_manual(values = palette()[5:6]) +
    labs(title = "linear model: y ~ log(x) + x")
```

## Moving forward with log - log model: Mixed effects

So, if my gamma GLM is not going to work, I will focus instead on using a mixed effect linear model. First, I'll determine random effects using full model.

```{r}

f0 <- formula(
  log(ba_inc_scaled) ~ log(dbh) * treatment + spp + year + cr
)


m1 <- lmer(update(f0, ~ . + (1 | tree_id) + (1 | plot)), REML = FALSE, data = test_d)
m2 <- update(m1, ~ . - (1 | plot))
m3 <- update(m1, ~ . - (1 | tree_id))
m4 <- update(m2, ~ . - (1 | tree_id) + (1 + dbh | plot))
m0 <- gls(f0, data = test_d, method = "ML")

AICc(m0, m1, m2, m3, m4)


```

Including plot in the random effects results in a singular fit and not random intercepts are calculated for plot, rendering it useless. This could mean that after accounting for fixed effects, there is no discernable variation in plot, or it could mean that there is some other problem. Either way, I don't think it makes any sense to include it right now.

`log_ba_inc_scaled ~ fixed_effects + (1 | tree_id)`

## log-log model fixed effects

```{r}

fl1 <- list(
  log(ba_inc_scaled) ~ log(dbh) + treatment + (1 | tree_id),
  log(ba_inc_scaled) ~ log(dbh) * treatment + (1 | tree_id),
  log(ba_inc_scaled) ~ log(dbh) * treatment + cr + (1 | tree_id),
  log(ba_inc_scaled) ~ log(dbh) + treatment + year + (1 | tree_id),
  log(ba_inc_scaled) ~ log(dbh) * treatment + year + (1 | tree_id),
  log(ba_inc_scaled) ~ log(dbh) * treatment + cr + year + (1 | tree_id),
  log(ba_inc_scaled) ~ log(dbh) + treatment + spp + (1 | tree_id),
  log(ba_inc_scaled) ~ log(dbh) * treatment + spp + (1 | tree_id),
  log(ba_inc_scaled) ~ log(dbh) * treatment + cr + spp + (1 | tree_id),
  log(ba_inc_scaled) ~ log(dbh) + treatment + year + spp + (1 | tree_id),
  log(ba_inc_scaled) ~ log(dbh) * treatment + year + spp + (1 | tree_id),
  log(ba_inc_scaled) ~ log(dbh) * treatment + cr + year + spp + (1 | tree_id),
  log(ba_inc_scaled) ~ log(dbh) * treatment + cr + year + spp + year:spp +(1 | tree_id),
  log(ba_inc_scaled) ~ log(dbh) + treatment + cr * year * spp + (1 | tree_id),
  log(ba_inc_scaled) ~ log(dbh) + treatment + cr * year * spp + treatment:spp + (1 | tree_id),
  log(ba_inc_scaled) ~ log(dbh) + treatment + cr:year + cr:spp + spp + (1 | tree_id)
)

get_aic(fl1, data = test_d, method = "lmm")

summary(lmer(fl1[[12]], data = test_d))
plot(predict(lmod(fl1[[12]])), resid(lmod(fl1[[12]]), type = "deviance"))

```

see:
[Cross validated post about zero variance](https://stats.stackexchange.com/questions/115090/why-do-i-get-zero-variance-of-a-random-effect-in-my-mixed-model-despite-some-va)

And the singular models section [here](https://bbolker.github.io/mixedmodels-misc/glmmFAQ.html#singular-models-random-effect-variances-estimated-as-zero-or-correlations-estimated-as---1)

Here is the model list above, with plot random effect, just in case.

```{r}

fl2 <- lapply(fl1, update_no_simplify, ~ . + (1 | plot))
get_aic(fl2, data = test_d, method = "lmm")

```


## What does all model selection have to say?

I'll use dredge from MuMIn to test all models

```{r}

options(na.action = "na.fail")

fm1 <- lmer(
  log(ba_inc_scaled) ~ log(dbh) * treatment + cr * year * spp + (1 | tree_id),
  data = test_d
)

dd <- dredge(fm1, m.lim = c(3, 10))

```

## Chosen full model regression table and marginal means

First I choose a model from above based on parsimony and AICc:

```{r}
ba_inc_mod <- 
```

## Modeling for each species

### Second year only

I'll split the dataset by species, for now I'll only model ba increment based on second period. That is the increment that we would be most interested in. I might also consider including tree_id as a random effect and year as a fixed effect.

```{r}

d_split <- test_d %>%
  filter(year == "13") %>%
  group_by(spp) %>%
  mutate(ba_inc_scaled_log = log(ba_inc1 - min(ba_inc1) + 0.1),
  ba_inc_scaled = ba_inc1 - min(ba_inc1) + 0.1
  ) %>%
  split(~ spp)

```

### Choosing a random effects structure

```{r ranef-spec}

test_ranef <- function(data) {
  f0 <- formula(ba_inc_scaled_log ~ dbh * treatment + cr)
  m0 <- gls(f0, data = data, method = "REML")
  m1 <- lmer(update(f0, ~ . + (1 | plot)), REML = TRUE, data = data)
  print(AICc(m0, m1))
  list(m0, m1)
}

mods <- map(d_split, test_ranef)
map(mods, ~summary(.x[[2]]))
summary(mods$SESE3[[2]])

# # This is applicable to a dataset that includes multiple years.
# f0 <- formula(
#   log(ba_inc1_scaled) ~ dbh * treatment + cr
# )
# m0 <- gls(f0, data = data, method = "REML")
# m1 <- lmer(update(f0, ~ . + (1 | plot)), REML = TRUE, data = data)
# m2 <- update(m1, ~ . + (1 | tree_id))
# m3 <- update(m2, ~ . - (1 | plot))
# m4 <- update(m2, ~ . + (0 + log(dbh) | plot))
```


This suggests that the optimal random effect for redwood is none! just a linear model. For fir, including plot as a random effect results in a marginally better AIC, but probably not worth it.

This may mean that I can just use a regular GLM with gamma distribution, but I don't know how to test whether this model is better than the log-transformed linear model.

### Test assumptions of linear model

If I am going to use the simple linear model with a log transformation, I should check the residuals for even variance. Unfortunately, I don't really like the looks of the residuals, especially for redwood.

```{r}

lmods <- map(d_split, ~lm(ba_inc_scaled_log ~ dbh * treatment + cr, data = .x))

plot(predict(lmods$SESE3), resid(lmods$SESE3))
plot(predict(lmods$PSMEM), resid(lmods$PSMEM))
```

If it turns out that the effect of plot does not really need to be accounted for, then maybe it would be acceptable to just fit a glm for most recent growth increment without any random effects. I'm using just a scaled response now.

```{r}

glmods <- map(d_split,
  ~glm(ba_inc_scaled ~ dbh * treatment + cr, data = .x), family = Gamma(link = "log")
  )

plot(predict(glmods$SESE3), resid(glmods$SESE3, type = "deviance"))
plot(predict(glmods$PSMEM), resid(glmods$PSMEM, type = "deviance"))

```

Here, I think that I [should not be seeing a pattern in the residuals][gamma residuals], but I am, so maybe this GLM model is also not appropriate. 

[gamma residuals](https://stats.stackexchange.com/questions/390063/what-are-the-assumptions-of-a-gamma-glm-or-glmm-for-hypothesis-testing)

### Both years

I'll test models with both years, this will necessitate trying different random effects and fixed effects to account for non-independence and quantify the effect of year.

```{r}

d_split2 <- test_d %>%
  group_by(spp) %>%
  mutate(
    ba_inc_scaled_log = log(ba_inc1 - min(ba_inc1) + 0.1),
    ba_inc_scaled = ba_inc1 - min(ba_inc1) + 0.1
  ) %>%
  split(~ spp)

```

A GLM gamma model seems like the best fit above.

```{r}

```


Here I'll split just by species and determine if interactions with year are important. For psme, including interaction between year and dbh alone is slightly better including more interactions with dbh, the difference is marginal, but the model is simpler.

```{r}
d_split2 <- split(test_d, ~spp)



aic_out2 <- map(d_split2, ~ get_aic(form_list2, data = .x, method = "glm"))
aic_out2
```

## Exploring marginal means of the most useful model

Based on the above, inclusion of interactions when considering a model with treatment and year, do not have lower AIC. I'll use:

`ba_inc1 + scale_val ~ dbh + treatment + year + (1 | plot)`

NOTE: Do we really care about year (first 5-year period or second), while it is true that there could be an different treatment effect for each year and even that this effect could vary by treatment (interaction), it seems as though the question we are trying to answer is dealing with long-term consequences. For instance, if we could report that a treatment had a strong effect, but only for 5 years and this effect is not persistent, than is it relevant to us? In writing this I realize that if a treatment is only "significant" in the second period, that could be important because it might suggest that there will be further long-term effects, whereas if a treatment is only important in the first period, then it may not really be that important after all.

```{r}
m7a <- glmer(
  I(ba_inc1 + scale_val) ~ scale(dbh) + treatment + year + (1 | plot),
  family = Gamma(link = "log"),
  data = d_split$SESE3
)
m7b <- glmer(
  I(ba_inc1 + scale_val) ~ scale(dbh) + treatment + year + (1 | plot),
  family = Gamma(link = "log"),
  data = d_split2$PSMEM
)
summary(m7a)
summary(m7b)
```

Here are pairwise comparisons for SESE, followed by PSME. low intensity is no different than control and high thinning is no different than low thinning.

```{r}

a_mean <- emmeans(m7a, ~ treatment + year)

# learning about back-transforming mean and SE
# it seems like using the "response" scale is working after all
emmeans(m7a, ~ treatment + year) %>% 
  as_tibble() %>%
  mutate(
    response = exp(emmean) - scale_val,
    se_response = exp(SE) - scale_val
  )
emmeans(m7a, ~ treatment + year, type = "response")

b_mean <- emmeans(m7b, ~ treatment + year)
pairs(a_mean)
contrast(a_mean)

```

Here is the trend from one period to the other. Its a little strange how consistent it is for each treatment. Climate effects? Or Is 

```{r}

emmip(m7a, treatment ~ year)
emmip(m7b, treatment ~ year)


emmeans(m7a, pairwise ~ treatment)
emmeans(m7b, pairwise ~ treatment)

```
