---
title: "Modeling BA increment"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = TRUE)
```

```{r}
library(lme4)
palette("Tableau 10")
library(patchwork)
```

# Introduction

Basal area increment is a key feature for analysis. Dbh data is available for almost all trees in both periods, it is more precise and diameter growth (as opposed to height growth) is expected to have a strong response to thinning treatments.

# Define trees of interest

For basal area increment, I will include all live trees without broken or dead tops. I am including trees identified as leaning, these should mostly have good growth and accurate measurements. I am excluding bear damaged trees.

```{r}
test_d <- d_l %>%
  # calculate SDI for each plot (additive method)
  group_by(plot) %>%
  mutate(sdi_plot = sum(12.5 * (dbh / 25.4)^1.605, na.rm = TRUE)) %>%
  ungroup() %>%
  # only use unbroken live sese or psme from 2018
  filter(
    spp %in% c("SESE3", "PSMEM"),
    year %in% c("18", "13"),
    status == 1,
    !get_cond(2, 3),
    !is.na(dbh)
  ) %>%
  mutate(
    treat_method = str_extract(treatment, "C|H|L"),
    treat_density = str_extract(treatment, "C|40|80"),
    treat_status = if_else(str_detect(treatment, "C"), "unthinned", "thinned"),
    year = factor(year, levels = c("13", "18"), ordered = FALSE)
  ) %>%
  mutate(year = factor(year, ordered = FALSE)) %>%
  select(-c(h_dist, azi, status, rot, cc, x, y, live))

# Remove bear damaged trees
test_d_bear <- test_d
test_d <- test_d[test_d$bear == FALSE, ]

# Alter one outlier record by using data from previous year
big_tree <- "4H80.4019"
replacement_data <- filter(test_d, tree_id == big_tree, year == "13") %>%
  mutate(
    dbh = dbh + d_inc * 5,
    d_inc = d_inc,
    ba = ba + ba_inc * 5,
    ba_inc = ba_inc
  )
bad_rec <- with(test_d, which(tree_id == big_tree & year == "18"))
test_d[bad_rec, names(replacement_data)] <- replacement_data

display_vars <- function(x) {
  select(x, c(tree_id, year, dbh, ht, bear, cr, notes, cond, d_inc, ba_inc))
}
```

Number of redwoods and Douglas fir trees in each plot and each treatment. Not including bear damaged trees.

```{r}
test_d %>%
  group_by(plot) %>%
  filter(year == "18") %>%
  mutate(n_sese = sum(spp == "SESE3")) %>%
  ggplot(aes(fct_reorder(plot, n_sese))) +
    geom_bar(aes(fill = spp)) +
    geom_text(
      aes(label = after_stat(count), group = spp),
      stat = "count",
      position = position_stack(vjust = .5)
    ) +
    scale_fill_manual(values = palette())

test_d %>%
  group_by(treatment) %>%
  filter(year == "18") %>%
  mutate(n_sese = sum(spp == "SESE3")) %>%
  ggplot(aes(fct_reorder(treatment, n_sese))) +
    geom_bar(aes(fill = spp)) +
    geom_text(
      aes(label = after_stat(count),
      group = spp),
      stat = "count",
      position = position_stack(vjust = .5)
    ) +
    scale_fill_manual(values = palette())
```

# Data exploration

## Outliers

Here I'm looking for any outliers in basal area increment, or extreme changes. There are definitely basal area outliers some of the most extreme can be explained by having bear damage, but on average, bear-damaged trees have diameter increments almost double those of non-bear-damaged. It is unclear whether this is due to loose bark, or the fact that these trees tend to be faster growing. This question might need further investigation. Following Dagley et. al 2018, I will remove bear damaged trees from analysis. Another option could be including bear damage as a covariate.


```{r}

# outliers defined as 1.5 times above or below IQR
test_d %>%
  filter(
    out(ba_inc)
  ) %>%
  group_by(tree_id) %>%
  arrange(ba_inc) %>%
  display_vars %>%
  color_groups()

# dot plot of outliers
test_d %>%
  ggplot(aes(x = d_inc, y = fct_reorder(tree_id, d_inc))) +
    geom_line(aes(group = tree_id), alpha = .3) +
    geom_point(aes(color = year), alpha = .5) +
    scale_y_discrete(breaks = NULL, expand = expansion(add = 10)) +
    scale_color_manual(values = palette()) +
    guides(color = guide_legend(override.aes = list(shape = c(19, 19)))) +
    labs(
      title = "Bear damaged trees excluded",
      x = "diameter increment (cm)",
      y = "tree id (sorted by diameter increment)"
    )

```

## Crown ratio

Crown ratio would be an important variable to include in a diameter increment model. Unfortunately, CR is missing for many trees---more than for heights:

```{r}
test_d %>%
  group_by(year) %>%
  summarize(
    "missing height" = sum(is.na(ht)),
    "missing cr" = sum(is.na(cr))
  ) %>%
  color_groups()
```

## Plotting data

First I'll look at distributions of the response:

```{r}
hist(test_d$ba_inc, main = "Basal area increment")
hist(log(test_d$ba_inc + 18), main = "Log of basal area increment + constant")
with(test_d, plot(dbh, ba_inc))
```


# Exploring models

## Basic model form

Basal area increment is expected to vary by dbh. I'll plot these by treatments, and or by year to assess relationship. In exploring the relationship between ba_inc and dbh I tried the following model forms:

```
model a: scaled_ba_inc = exp((dbh) * treatment * spp), gamma distribution
model b: scaled_ba_inc = exp((dbh) * treatment * spp), gaussian distribution
model c: log(ba_inc) = dbh * treatment * spp 
model d: ba_inc = (log(dbh) + dbh) * treatment * spp
```
The scaling value was computed as `abs(min(ba_inc)) + 1`

```{r, fig.height=7, fig.width=10}
scale_val <- with(test_d, abs(min(ba_inc)) + 1)

m6a <- glm(
  I(ba_inc + scale_val) ~ dbh * treatment * spp,
  family = Gamma(link = "log"),
  data = test_d
)

m6b <- glm(
  I(ba_inc + scale_val) ~ dbh * treatment * spp,
  family = gaussian(link = "log"),
  data = test_d
)

m6c <- lm(log(ba_inc + scale_val) ~ dbh * treatment * spp, data = test_d)

m6d <- lm(ba_inc ~ log(dbh) + dbh * treatment * spp, data = test_d)

test_d %>%
  ungroup() %>%
  mutate(
    as_tibble(predict(m6a, se.fit = TRUE)[1:2]),
    upr = exp(fit + 2 * se.fit),
    lwr = exp(fit - 2 * se.fit)
    ) %>%
  ggplot(aes(y = ba_inc, x = dbh, color = spp)) +
    geom_point(alpha = 0.3) +
    geom_line(aes(y = predict(m6a, type = "response") - scale_val), size = 1) +
    geom_ribbon(
      aes(ymin = lwr - scale_val, ymax = upr - scale_val, group = spp),
      alpha = 0.2,
      color = NA
    ) +
    facet_wrap(vars(treatment)) +
    scale_color_manual(values = palette()) +
    labs(title = "gamma GLM with log link")

test_d %>%
  ggplot(aes(x = dbh, y = ba_inc + scale_val, color = spp)) +
    geom_point(alpha = .2) +
    facet_wrap(vars(treatment)) +
    geom_smooth(
      method = "glm",
      formula = y ~ x,
      method.args = list(family = gaussian(link = "log"))
    ) +
    scale_color_manual(values = palette()) +
    labs(title = "Gaussian glm wih log link")

test_d %>%
  ggplot(aes(x = dbh, y = log(ba_inc + scale_val), color = spp)) +
    geom_point(alpha = .2) +
    facet_wrap(vars(treatment)) +
    geom_smooth(method = "lm", formula = y ~ x) +
    scale_color_manual(values = palette()) +
    labs(title = "Linear model, log-transformed")

test_d %>%
  ggplot(aes(x = dbh, y = ba_inc, color = spp)) +
    geom_point(aes(), alpha = .2) +
    geom_smooth(method = "lm", formula = y ~ log(x) + x) +
    facet_wrap(vars(treatment)) +
    scale_color_manual(values = palette()[5:6]) +
    labs(title = "linear model: y ~ log(x) + x")
```

I don't think that the model with transformed response is comparable but the other three I think are. The gamma glm with log link has the lowest AIC. I will use it moving forward.

```{r}
AIC(m6a, m6b, m6c, m6d)
```

## Modeling with subsets

Next I'll split the data by species and year and determine the best categorical predictor ie, treatment, treatment intensity, treatment status, or sdi and treatment status. Im using `plot` as a random effect.

For Douglas-fir and redwood, treatment density appears to be the best predictor in both years. For redwood, inclusion of interaction with dbh has a lower AIC. For Douglas-fir, 

This suggests that I could combine years.

```{r}

d_split1 <- split(test_d, ~ year + spp)

form_list1 <- list(
  I(ba_inc + scale_val) ~ dbh + treatment + (1 | plot),
  I(ba_inc + scale_val) ~ dbh + treat_method + (1 | plot),
  I(ba_inc + scale_val) ~ dbh + treat_density + (1 | plot),
  I(ba_inc + scale_val) ~ dbh + treat_status + (1 | plot),
  I(ba_inc + scale_val) ~ dbh * treatment + (1 | plot),
  I(ba_inc + scale_val) ~ dbh * treat_method + (1 | plot),
  I(ba_inc + scale_val) ~ dbh * treat_density + (1 | plot),
  I(ba_inc + scale_val) ~ dbh * treat_status + (1 | plot),
  I(ba_inc + scale_val) ~ dbh + treat_status + sdi_plot + (1 | plot),
  I(ba_inc + scale_val) ~ dbh * treat_status + sdi_plot + (1 | plot)
)

aic_out1 <- map(d_split1, ~ get_aic(form_list1, data = .x, method = "glm")[1:5, ])

aic_out1
```

Here I'll split just by species and determine if interactions with year are important. For psme, including interaction between year and dbh alone is slightly better including more interactions with dbh, the difference is marginal, but the model is simpler.

```{r}
d_split2 <- split(test_d, ~spp)

form_list2 <- list(
  I(ba_inc + scale_val) ~ dbh + treatment + (1 | plot),
  I(ba_inc + scale_val) ~ dbh + treat_method + (1 | plot),
  I(ba_inc + scale_val) ~ dbh + treat_density + (1 | plot),
  I(ba_inc + scale_val) ~ dbh + treat_status + (1 | plot),
  I(ba_inc + scale_val) ~ dbh + treat_method + (1 | plot),
  I(ba_inc + scale_val) ~ dbh + treat_density + (1 | plot),
  I(ba_inc + scale_val) ~ dbh + treat_status + (1 | plot),
  I(ba_inc + scale_val) ~ dbh + treatment + year + (1 | plot),
  I(ba_inc + scale_val) ~ dbh + treat_method + year + (1 | plot),
  I(ba_inc + scale_val) ~ dbh + treat_density + year + (1 | plot),
  I(ba_inc + scale_val) ~ dbh + treat_status + year + (1 | plot),
  I(ba_inc + scale_val) ~ dbh * treatment + year + (1 | plot),
  I(ba_inc + scale_val) ~ dbh * treat_method + year + (1 | plot),
  I(ba_inc + scale_val) ~ dbh * treat_density + year + (1 | plot),
  I(ba_inc + scale_val) ~ dbh * treat_status + year + (1 | plot),
  I(ba_inc + scale_val) ~ dbh * treatment * year + (1 | plot),
  I(ba_inc + scale_val) ~ dbh * treat_method * year + (1 | plot),
  I(ba_inc + scale_val) ~ dbh * treat_density * year + (1 | plot),
  I(ba_inc + scale_val) ~ dbh * treat_status * year + (1 | plot),
  I(ba_inc + scale_val) ~ dbh + treat_status * sdi_plot + (1 | plot),
  I(ba_inc + scale_val) ~ dbh + treat_status + sdi_plot + (1 | plot),
  I(ba_inc + scale_val) ~ dbh * treat_density + year + year:dbh + (1 | plot),
  I(ba_inc + scale_val) ~ dbh * treat_density + year + year:treat_density +(1 | plot),
  I(ba_inc + scale_val) ~ dbh * treat_density + year + year:treat_density + year:dbh +(1 | plot)

)

aic_out2 <- map(d_split2, ~ get_aic(form_list2, data = .x, method = "glm"))
aic_out2
```

## Exploring marginal means of the most useful model

Based on the above, inclusion of interactions when considering a model with treatment and year, do not have lower AIC. I'll use:

`ba_inc + scale_val ~ dbh + treatment + year + (1 | plot)`

NOTE: Do we really care about year (first 5-year period or second), while it is true that there could be an different treatment effect for each year and even that this effect could vary by treatment (interaction), it seems as though the question we are trying to answer is dealing with long-term consequences. For instance, if we could report that a treatment had a strong effect, but only for 5 years and this effect is not persistent, than is it relevant to us? In writing this I realize that if a treatment is only "significant" in the second period, that could be important because it might suggest that there will be further long-term effects, whereas if a treatment is only important in the first period, then it may not really be that important after all.

```{r}
m7a <- glmer(
  I(ba_inc + scale_val) ~ scale(dbh) + treatment + year + (1 | plot),
  family = Gamma(link = "log"),
  data = d_split2$SESE3
)
m7b <- glmer(
  I(ba_inc + scale_val) ~ scale(dbh) + treatment + year + (1 | plot),
  family = Gamma(link = "log"),
  data = d_split2$PSMEM
)
summary(m7a)
summary(m7b)
```

Here are pairwise comparisons for SESE, followed by PSME. low intensity is no different than control and high thinning is no different than low thinning.

```{r}

a_mean <- emmeans(m7a, ~ treatment + year)

# learning about back-transforming mean and SE
# it seems like using the "response" scale is working after all
emmeans(m7a, ~ treatment + year) %>% 
  as_tibble() %>%
  mutate(
    response = exp(emmean) - scale_val,
    se_response = exp(SE) - scale_val
  )
emmeans(m7a, ~ treatment + year, type = "response")

b_mean <- emmeans(m7b, ~ treatment + year)
pairs(a_mean)
contrast(a_mean)

```

Here is the trend from one period to the other. Its a little strange how consistent it is for each treatment. Climate effects? Or Is 

```{r}

emmip(m7a, treatment ~ year)
emmip(m7b, treatment ~ year)


emmeans(m7a, pairwise ~ treatment)
emmeans(m7b, pairwise ~ treatment)

```
