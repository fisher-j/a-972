# ---
title: "A972 - data prep"
output: 
  html_document:
    toc: true
author: Judson Fisher
date: "`r format(Sys.Date(), '%m/%d/%Y')`"
# bibliography: bib.json
---
```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = TRUE, message = FALSE)
```

```{r extra-functions}
# Functions to add to their own file

# Tell summary functions to group by species or not
group_vars <- function(by_species = FALSE) {
  if(by_species) {
    alist(spp, treatment, year)
  } else {
    alist(treatment, year)
  }
}

# color table by groups function, only works if table is
# properly arranged.
color_groups <- function(x, caption = "", background = "#EEE9E9") {
  even_groups <- x %>%
    rownames_to_column() %>%
    filter(cur_group_id() %% 2 == 0) %>%
    pull(rowname) %>%
    as.numeric()
  x %>%
    kbl(caption = caption) %>%
    kable_styling(full_width = FALSE) %>%
    row_spec(even_groups, background = background)
}

# Outlier Function
out <- function(x, mag = 1.5) {
  qu <- quantile(x, c(.25, .75), na.rm = TRUE)
  bounds <- c(lower = qu[[1]] - mag * IQR(x, na.rm = TRUE),
              upper = qu[[2]] + mag * IQR(x, na.rm = TRUE))
  outliers <- x < bounds["lower"] | x > bounds["upper"]
  outliers[is.na(outliers)] <- FALSE
  outliers
}

# Plot ht vs dbh with square root transformation and
# highlight outliers
plot_ht <- function(data, mag = 1.5) {
  mod <- lm(ht ~ sqrt(dbh), data = data)
  plot(data$dbh, data$ht, col = "gray30")
  curve(coef(mod)[1] + coef(mod)[2] * sqrt(x), add = TRUE, col = "deeppink")
  out_resid <- as.numeric(names(resid(mod))[out(resid(mod), mag = mag)])
  points(data$dbh[out_resid], data$ht[out_resid], col = "hotpink")
  title(paste(format(formula(mod)), "\n", "residuals >", mag, "x IQR"))
  invisible(out_resid)
}

# function to filter condition values with OR logic
get_cond <- function(...) {
  vals <- unlist(list(...))
  cond <- evalq(cond, parent.frame())
  map_lgl(str_split(cond, ","), ~ any(as.numeric(.x) %in% vals))
}
```


# Import Data

I'll start by importing tree data from all three periods as well as the tree list. These will be stored in four appropriately named data frames. While importing, I'll rename some columns, select useful columns and remove the "spare" observations. I combine condition codes into a single column.

```{r}
library("tidyverse")
library(kableExtra)

tree_2008 <- read.csv("./original/tblA972_TreeData2008.txt",
                           na.strings = "") %>%
  select(tree_id = TreeID, dbh = DBH, ht = HTt, cr = CR,
        status = Status, bear = BearDmg, rot = Rot, notes = Notes) %>%
        filter(!grepl("^SPR1", tree_id)) %>%
  as_tibble()

tree_2013 <- read.csv("./original/tblA972_TreeData2013.txt",
                           na.strings = "") %>%
  select(tree_id = TreeID, dbh = DBH, ht = Ht, cr = CR, cc = CC,
         status = Status, bear = BearDmg, ConCode.A:ConCode.E,
         notes = Notes) %>%
  unite(cond, starts_with("ConCode"), sep = ",", na.rm = TRUE) %>%
  filter(!grepl("^SPR1", tree_id)) %>%
  as_tibble()

tree_2018 <- read.csv("./original/tblA972_TreeData2018.txt",
                           na.strings = "") %>%
  select(tree_id = TreeID, dbh = DBH, ht = HTt, cr = CR,
         status = Status, ConCode.A:ConCode.E, bear = BearDmg,
         notes = Notes) %>%
  unite(cond, starts_with("ConCode"), sep = ",", na.rm = TRUE) %>%
  filter(!grepl("^SPR1", tree_id)) %>%
  as_tibble()

tree_list_all <- read.csv("./original/tblA972_Trees.txt", na.strings = "") %>%
  select(plot = Plot_ID, tree_id = TreeID, spp = Species,
         h_dist = H_Dist, azi = Azimuth) %>%
  filter(!grepl("^SPR1", tree_id)) %>%
  as_tibble()
```

# Initial data cleaning

## Status column
I'll remove bad data indicated by status -99, -999, or -9999. These occur in 2013. 


```{r}
bad_id <- tree_2013$tree_id[tree_2013$status %in% c(-99, -999, -9999)]
data.frame(id = bad_id,
           notes_08 = tree_2008$notes[tree_2008$tree_id %in% bad_id],
           notes_13 = tree_2013$notes[tree_2013$tree_id %in% bad_id])
tree_2008 <- tree_2008[!tree_2008$tree_id %in% bad_id, ]
tree_2013 <- tree_2013[!tree_2013$tree_id %in% bad_id, ]
tree_2018 <- tree_2018[!tree_2018$tree_id %in% bad_id, ]
tree_list_all <- tree_list_all[!tree_list_all$tree_id %in% bad_id, ]


```

I'll also look at trees with status == 99, and determine if they (a) died after harvest, and thus are period 1 mortality, or (b) died before harvest, and were snags. I also give status=1 to ingrowth in 2018 (where status was NA). Finally, some down, windthrown trees (broken below dbh or uprooted) continue to have dbh recorded (44), and others do not (115). I'm not sure how to handle this for now.

```{r}
# Deal with status 99
tree_2008[tree_2008$status == 99, "status"]
tree_2008[tree_2008$status == 99, "status"] <- c(5, 5, 1, 1)

# Deal with status=NA in 2018
tree_2018[is.na(tree_2018$status), "status"] <- 1

```

Changing status of one "split" tree from "live" to "broken above dbh" and one snag from -5 to 5.

```{r}
tree_2013[tree_2013$tree_id == "4L40.3255", "status"] <- 31
tree_2018[tree_2018$tree_id == "1L40.3661", "status"] <- 5
```

Change status of several windthrow trees from 1 to 30 or 31, based on condition codes. These are strange because, subsequent dbh for these trees continue to increase, despite them being windthrown. I'm not sure what to make of this. 

```{r}
bad_windthrow_13 <- tree_2013$status == 1 & grepl("30|31|32", tree_2013$cond)
new_status_13 <- str_extract(tree_2013$cond[bad_windthrow_13], "30|31|32")
tree_2013[bad_windthrow_13, "status"] <- as.numeric(new_status_13)

bad_windthrow_18 <- tree_2018$status == 1 & grepl("30|31|32", tree_2018$cond)
new_status_18 <- str_extract(tree_2018$cond[bad_windthrow_18], "30|31|32")
tree_2018[bad_windthrow_18, "status"] <- as.numeric(new_status_18)
```

## Cut trees
The 2008 data needs to be broken into initial and post cut conditions. To separate these I'll use the Status column ("15" and "16" indicate cut). Initial conditions will include cut and uncut trees. I'll make sure tree_2008 doesn't have any remaining cut trees, then I'll check subsequent measurement periods to make sure there are no more remaining cut trees. Finally, I'll remove harvested trees from tree_list_all.

While ids (with a "C") don't indicate any unexpected cut trees in subsequent years, year 2013 has two cut trees indicated by status 16. One of these, 2L80.3731 is listed as windthrown prior to harvest in 2008, this tree should be omitted as it is not representative of treatment effects. Tree 3H40.3195 was listed as alive in 2008 and then as cut in 2013, I'm going to assume it was actually cut in 2008 (when it was 5.5 inches).

```{r}
init_2008 <- tree_2008
tree_2008 <- tree_2008[!init_2008$status %in% c(15, 16), ]

# check for possible unmatched cut trees in tree_2008
# (id's with "C" in second part)
pattern <- "\\w+\\.([Cc]\\d+)|(\\d+[Cc])"
tree_2008[grepl(pattern, tree_2008[["tree_id"]]), ]

# Check if there are trees with "C" in subsequent years. There are not.
tree_2013[grepl(pattern, tree_2013[["tree_id"]]), ]
tree_2018[grepl(pattern, tree_2018[["tree_id"]]), ]

# Check for status 15 or 16 in subsequent years: 2 cut trees in 2013
tree_2013[tree_2013$status %in% c(15, 16), ]
tree_2018[tree_2018$status %in% c(15, 16), ]

# remove pre-harvest windthrown tree
bad_id <- "2L80.3731"
tree_2008 <- tree_2008[!tree_2008$tree_id %in% bad_id, ]
tree_2013 <- tree_2013[!tree_2013$tree_id %in% bad_id, ]
tree_2018 <- tree_2018[!tree_2018$tree_id %in% bad_id, ]
tree_list_all <- tree_list_all[!tree_list_all$tree_id %in% bad_id, ]

# assume 3H40.3195 was actually cut in 2008
cut_13 <- "3H40.3195"
tree_2013 <- tree_2013[!tree_2013$tree_id %in% cut_13, ]
tree_2008 <- tree_2008[!tree_2008$tree_id %in% cut_13, ]
new_data <- list(tree_id = paste0(cut_13, "C"), status = 16)
init_2008[init_2008$tree_id %in% cut_13, c("tree_id", "status")] <- new_data
tree_list_all[tree_list_all$tree_id %in% cut_13, "tree_id"] <- new_data$tree_id

# get ids of cut trees and remove from tree list
cut_ids <- init_2008$tree_id[init_2008$status %in% c(15, 16)]
tree_list <- tree_list_all[!tree_list_all$tree_id %in% cut_ids, ]
```

## Bear/rot column
Covert bear damage and rot to TRUE/FALSE, rather than Y/N or 1/(missing)

```{r}
init_2008$bear <- if_else(init_2008$bear == "Y", TRUE, FALSE)
init_2008$rot <- if_else(init_2008$rot == "Y", TRUE, FALSE)
tree_2008$bear <- if_else(tree_2008$bear == "Y", TRUE, FALSE)
tree_2008$rot <- if_else(tree_2008$rot == "Y", TRUE, FALSE)
tree_2013$bear <- if_else(tree_2013$bear == 1, TRUE, FALSE, missing = FALSE)
tree_2018$bear <- if_else(tree_2018$bear == 1, TRUE, FALSE, missing = FALSE)
```

In 2018, "bear" column does not agree with bear damage recorded in "condition codes," I'll default to using the condition codes and adjust "bear" accordingly.

```{r}
any(tree_2018$bear == FALSE & str_detect(tree_2018$cond, "17|18|19"))
tree_2018[str_detect(tree_2018$cond, "17|18|19"), "bear"] <- TRUE
```

## Initial Complete dataset

I'll check to make sure all tree_ids for all measurement years are represented in the tree list and vice-versa. Then I'll make a long format dataset where each observation has one row by simply attaching each dataset together, end to end and adding a column for the year. This format should be efficient for producing summary statistics. I am including initial conditions in this dataset and convert to metric. I also fix notes that have multiple lines.

```{r}
all_years <- list(`init` = init_2008, `08` = tree_2008,
                   `13` = tree_2013, `18` = tree_2018)
after_harvest <- all_years[names(all_years) != "init"]
ids <- lapply(after_harvest, "[[", "tree_id")
ids <- Reduce(union, ids)
# check extra tree_list ids
setdiff(tree_list$tree_id, ids)
# check extra measurement data ids
setdiff(ids, tree_list$tree_id)

# long format dataset (includes initial conditions)
# and convert to metric
treatments <- paste("H40", "L40", "H80", "L80", "C", sep = "|")
d_l <- bind_rows(all_years, .id = "year")
d_l <- left_join(tree_list_all, d_l, by = "tree_id") %>%
  mutate(treatment = str_extract(plot, treatments), .after = plot) %>%
  mutate(h_dist = h_dist / 3.281, dbh = dbh * 2.54, ht = ht / 3.281) %>%
  mutate(year = factor(year, levels = names(all_years), ordered = TRUE))

d_l <- d_l %>%
  mutate(notes = gsub("\n.*", "", notes),
         cond = replace_na(cond, ""))

```

## Ingrowth

Ingrowth is important for metrics such as structural diversity, understory diversity and others, but might skew metrics relating to the growth of dominant trees of interest. Here I remove ingrowth from the main dataset.

```{r}
ingrowth <- d_l %>%
  group_by(tree_id) %>%
  filter(min(year) > "08") %>%
  ungroup()

d_l <- d_l %>%
  group_by(tree_id) %>%
  filter(min(year) < "13") %>%
  ungroup()
```

# Detailed data cleaning

Considering each summary statistic, I'll look for potential problems in each column of the dataset, looking for outliers and repairing values if needed.

## DBH data cleaning

I'll start by taking a look at the dbh quartiles. There are zeros. They only occur in statuses 30, 31, 32 and 5 (snags and windfalls). I'll convert these zeros to "NA".

```{r}
summary(d_l$dbh)
d_l %>% filter(dbh == 0) %>% pull(status) %>% unique()
d_l$dbh[d_l$dbh == 0] <- NA
```

I look at a summary of all dbh then I identify dbh outliers among post-harvest trees, there are 77 separate observations (including remeasures), none of the dbh's are obviously extreme. 

```{r}
summary(filter(d_l, year != "init")$dbh)

dbh_out <- boxplot(filter(d_l, year != "init")$dbh, plot = FALSE)$out
length(dbh_out)
```

I check for dbh among all post harvest trees that change dramatically from one observation to the next because this may indicate a measurement error. *This includes dbh measurements for some downed trees, which may or may not be appropriate.* Outliers are defined as 1.5 times inter-quartile range above Q3 or below Q1, and are determined separately for both growth periods, but across all species and treatments. I also select anything with more than 1" shrinkage.

```{r, echo = FALSE}
change_d <- d_l %>%
  filter(year != "init") %>%
  pivot_wider(id_cols = c(tree_id, spp, plot), names_from = year,
              values_from = c(dbh, notes, bear, cr, status)) %>%
  mutate(p1 = dbh_13 - dbh_08, p2 = dbh_18 - dbh_13)
```
```{r}
# Period one summary
summary(change_d$p1)

# Period two summary
summary(change_d$p2)
```

```{r, echo = FALSE}
# Get diameter change outliers in both periods
out_d <- change_d %>%
  select(p1, p2) %>%
  map(~filter(change_d, .x %in% boxplot(.x, plot = FALSE)$out | .x < -2.54))
```

Average growth by *species and treatment* to be used to help identify and fix problems with dbh's. I looked at grouping by *species and plot*, but there were often too few trees for a good average. I'm assuming here that the response of species to treatment captures the most meaningful data for our purposes. 

```{r, echo = FALSE}

change_d %>%
  group_by(treatment = str_extract(plot, "L40|L80|H40|H80|C"), spp) %>%
  summarise(p1_mean = signif(mean(p1, na.rm = TRUE), 3),
            p2_mean = signif(mean(p2, na.rm = TRUE), 3),
            .groups = "drop") %>%
  rbind(rep(NA, 4)) %>%
  {bind_cols(.[1:11, ], .[12:22, ], .name_repair = "minimal")} %>%
  ungroup() %>%
  kbl() %>%
  kable_styling()

```

### Identify dbh to fix

I'll look at change outliers that occur in p1 or p2, but not both and I'll manually select entries to remove from the dbh summary. 

* If the first or las dbh seems unlikely, project a value using either the other periods dbh change or the average change for that species/treatment.
* If the tree seems very unhealthy, allow up to 10% shrinkage per measurement period with a 15% maximum.
* If the middle measurement seems unlikely:
  * consider averaging first and last
  * project growth based on other period, or average
* project actual growth for trees that "grew together with neighbor" using previous period and average growth.
* Assume extreme growth on very bear damaged trees may be due to bark abnormalities - adjust.
* Assume rapid growth is unlikely when a tree dies in following period with no bear damage.

I'm also fixing dbh of trees whose tag was removed because they grew together with their neighbor. I project dbh growth for these trees based on average growth (by species and treatment) and previous/subsequent period growth.

Pink highlight indicates outlier values (for individual measurements as well as height increment). Salmon highlight indicates edited values with new value in parentheses.

```{r, echo = FALSE}
dbh_problem1 <- out_d %>%
  reduce(full_join) %>%
  bind_rows(filter(change_d, if_any(starts_with("status"), ~ .x == 20))) %>%
  select(-plot)

new_dbh <- tribble(
  ~tree_id,    ~year, ~dbh,
  "1H80.3589", "08", 13.3,
  "1H80.3621", "13", 34.53,
  "1L80.3456", "08", 49.5,
  "3L80.3361", "08", 15.3,
  "4L80.3296", "08", 17.6,
  "C2.4244",   "13", 17.78,
  "C2.4252",   "08", 24.4,
  "C2.4301",   "08", 22.14,
  "C2.4301",   "13", 20.03,
  "C2.4301",   "18", NA,
  "C4.4636",   "08", 17.02,
  "1H80.3620", "18", 31.8,
  "1L40.3656", "18", 35.9,
  "2H40.3067", "08", 44.83,
  "2H80.3164", "18", 36.1,
  "2L80.3724", "18", 53.6,
  "3L80.3365", "18", 30.7,
  "4L40.3276", "18", 46.25,
  "C4.4601",   "18", 55.37,
  "1H80.3529", "13", 31.4,
  "1H80.3619", "18", 18.8,
  "2H80.4110", "18", 23.6,
  "2L80.3725", "18", 37.6,
  "3L80.3366", "18", 34.5,
  "4L40.3277", "18", 40.9,
  "C4.4600",   "18", 29.0,
  ) %>%
  mutate(year = factor(year, levels = c("08", "13", "18"), ordered = TRUE))
```

```{r, echo = FALSE}
# Color the values that are being changed as well as the outlier values
dbh_color <- split(new_dbh, ~year) %>%
  map("tree_id") %>%
  map(~ifelse(dbh_problem1$tree_id %in% .x, "Salmon", "White"))
  
outlier_color <- map(out_d, "tree_id") %>%
  map(~if_else(dbh_problem1$tree_id %in% .x, "Pink", "White"))

# prepare replacement data to add to colored table
problem_wide <- new_dbh %>%
  group_by(tree_id) %>%
  complete(year) %>%
  pivot_wider(names_from = year, values_from = dbh, names_prefix = "dbh_")


show_fix <- function(old, new) {
  if_else(!is.na(new), paste0(old, " (", new, ")"), as.character(old))
}

# Make colored table with updated values
dbh_problem1 %>%
  left_join(problem_wide, by = "tree_id", suffix = c("", "_new")) %>%
  mutate(dbh_08 = show_fix(dbh_08, dbh_08_new),
         dbh_13 = show_fix(dbh_13, dbh_13_new),
         dbh_18 = show_fix(dbh_18, dbh_18_new)) %>%
  select(!ends_with("new")) %>%
  unite("bear_seq", starts_with("bear"), sep = ">") %>%
  unite("cr_seq", starts_with("cr"), sep = ">") %>%
  unite("status_seq", starts_with("status"), sep = ">") %>%
  kbl() %>%
  kable_styling(bootstrap_options = "hover") %>%
  column_spec(3, background = dbh_color[[1]]) %>%
  column_spec(4, background = dbh_color[[2]]) %>%
  column_spec(5, background = dbh_color[[3]]) %>%
  column_spec(12, background = outlier_color[[1]]) %>%
  column_spec(13, background = outlier_color[[2]])
```

### *Update dbh values in main dataset*

Here I'll update the dbh data in the main dataset with the values identified above. I'll also change status 20 to 1 (live tree). Below this point, d_l is an updated dataset.

```{r}
# make sure year factors match eg. "init"
new_dbh$year <- ordered(new_dbh$year, levels = levels(d_l$year))
d_l <- rows_update(d_l, new_dbh, by = c("tree_id", "year"))
# make sure all status 20 are accounted for
all(d_l$tree_id[d_l$status == 20] %in% new_dbh$tree_id)
# Change status 20, update post harvest data
d_l[d_l$status == 20, "status"] <- 1
p_h <- filter(d_l, year > "init")
```

## Height data cleaning


I'll start by identifying and eliminating zeros and bad data (-30.2m = -99ft) from height data and replace these with NA.

```{r}
d_l %>%
  group_by(year, treatment) %>%
    summarize(min = min(ht, na.rm = TRUE),
            `1st qu.` = quantile(ht, .25, na.rm = TRUE),
            median = median(ht, na.rm = TRUE),
            mean = mean(ht, na.rm = TRUE),
            `3rd qu.` = quantile(ht, .75, na.rm = TRUE),
            max = max(ht, na.rm = TRUE),
            na = sum(is.na(ht)))

d_l <- d_l %>%
  mutate(ht = if_else(ht * 3.281 == -99 | ht == 0, NA_real_, ht))
```

### Fixing Status and Condition Codes

Here I make changes to status and condition codes. I add condition codes to, and change the status of some trees based on their notes and height information to identify leaning, broken-top, and broken above dbh height anomalies. If a tree is broken below 7m, then it should be status 31, "broken above dbh", rather than just a broken top.

```{r}

  # New condition codes
cond_new <- tribble(
  ~tree_id, ~year, ~cond,
  "1H40.1908", "08", "3",
  "2H40.3064", "13", "3",
  "2L80.3729", "08", "3",
  "3H80.3839", "13", "31",
  "3L40.3211", "13", "31",
  "4H80.3975", "13", "3",
  "4H80.4005", "08", "3",
  "4H80.4011", "08", "3",
  "4H80.4027", "13", "3",
  "C1.4204",   "08", "2",
  "C2.4295",   "13", "3",
  "1L80.3399", "08", "3",
  "1L80.3399", "13", "3",
)

# Update condition codes
key <- map(list(d_l, cond_new), ~paste(.x$tree_id, .x$year))
vals_to_change <- match(key[[2]], key[[1]])
new_vals <- paste(d_l$cond[vals_to_change], cond_new$cond, sep = ",") %>%
  str_remove("^,|,$")
d_l$cond[vals_to_change] <- new_vals

# New status
status_new <- tribble(
  ~tree_id, ~year, ~status,
  "3H80.3839", "13", 31,
  "3H80.3839", "18", 31,
  "3L40.3207", "13", 31,
  "3L40.3207", "18", 31,
  "4L40.3283", "08", 31,
  "C3.4530",   "13", 31,
  "1H80.3581", "18", 31,
  "4L40.3255", "18", 31,
  "4L40.3262", "18", 31,
  "1L40.3661", "13", 5,
)

# Update datasets with new status
d_l <- rows_update(d_l, status_new, by = c("tree_id", "year"))

# If a tree with "broken top" is less than 5m, then it should be
# status 31, broken above dbh
broken_low <- with(d_l, which(get_cond(3) & ht < 5 & status == 1))
d_l[broken_low, "status"] <- 31

p_h <- filter(d_l, year > "init")
```

### Height outliers

Next, I'll look for absolute outliers in height. First I'll fit a linear model (square-root transformed) and get the extreme residuals by defining an arbitrary cutoff.

```{r ht_plot1, echo = FALSE}

p_h <- filter(d_l, year > "init")

# vector of positions in original dataset that are out
ht_outlier_resid <- plot_ht(p_h, mag = 2.5)

# Get tree id and year for each outlier
ht_outlier_resid <- p_h[ht_outlier_resid, c("tree_id", "year")]

```

I also want to look at extreme changes in height. I'll combine these two sets of outliers and look for height values that need fixing. I'm looking at outlier height increments that are 2 times above or below the IQR. Pink highlight indicates outlier values (for individual measurements as well as height increments). Salmon highlight indicates edited values with new value in parentheses. 

```{r, echo=FALSE}
# Define the delta-height dataset in wide format
change_h <- p_h %>%
  pivot_wider(id_cols = c(tree_id, spp, plot), names_from = year,
              values_from = c(ht, dbh, notes, bear, cr, status, cond)) %>%
  mutate(p1 = ht_13 - ht_08, p2 = ht_18 - ht_13) %>%
  mutate(across(where(is.double), round, 2))

# compile list of all target outlier tree ids
ht_outlier <- select(change_h, p1:p2) %>%
  map(~ out(.x, mag = 2)) %>%
  map(~ change_h$tree_id[.x]) %>%
  c(resid = list(unique(ht_outlier_resid$tree_id)))

# Define height problem dataset
problem_ht <- filter(change_h, tree_id %in% reduce(ht_outlier, union))

```


```{r}
# New tree heights
new_ht <- tribble(
  ~tree_id,    ~year, ~ht,
  "1L80.3400", "08",  21,
  "1L80.3402", "13",  15.8,
  "2H40.3049", "08",  15,
  "2H40.3073", "18",  24,
  "2H40.3075", "13",  17,
  "2H80.3094", "18",  18,
  "2H80.3099", "18",  15,
  "2H80.3175", "18",  30,
  "2H80.4105", "13",  26,
  "2H80.4111", "13",  22,
  "3H40.1859", "18",  21,
  "3H80.3790", "13",  16,
  "3L80.3320", "08",  15,
  "3L80.3374", "18",  21,
  "4H80.4000", "18",  26.5,
  "4L40.3278", "18",  18,
  "4L40.3283", "08",  8.5,
  "C1.4146",   "18",  21,
  "C1.4197",   "13",  19,
  "C4.4676",   "18",  28,
  ) %>%
  mutate(
    year = factor(year, levels = c("init", "08", "13", "18"), ordered = TRUE)
  )

```

```{r, echo=FALSE}
# Color the values that are being changed as well as the
# height increment outlier values and the residual outliers

ht_resid_color <- split(ht_outlier_resid, ~ year, drop = TRUE) %>%
  map("tree_id") %>%
  map(~if_else(problem_ht$tree_id %in% .x, "Pink", "White"))

ht_fix_color <- split(new_ht, ~year, drop = TRUE) %>%
  map("tree_id") %>%
  map2(ht_resid_color, ~ifelse(problem_ht$tree_id %in% .x, "Salmon", .y))

ht_change_color <- ht_outlier[c("p1", "p2")] %>%
  map(~if_else(problem_ht$tree_id %in% .x, "Pink", "White"))

# prepare replacement data to add to colored table
new_ht_wide <- new_ht %>%
  group_by(tree_id) %>%
  complete(year) %>%
  pivot_wider(names_from = year, values_from = ht, names_prefix = "ht_") %>%
  select(-ht_init)


problem_ht %>%
  left_join(new_ht_wide, by = "tree_id", suffix = c("", "_new")) %>%
  mutate(ht_08 = show_fix(ht_08, ht_08_new),
         ht_13 = show_fix(ht_13, ht_13_new),
         ht_18 = show_fix(ht_18, ht_18_new)) %>%
  select(!c(ends_with("new"), plot)) %>%
  unite("bear_seq", starts_with("bear"), sep = ">") %>%
  unite("cr_seq", starts_with("cr"), sep = ">") %>%
  unite("status_seq", starts_with("status"), sep = ">") %>%
  unite("dbh_seq", starts_with("dbh"), sep = ">") %>%
  unite("cond_seq", starts_with("cond"), sep = ">") %>%
  kbl() %>%
  kable_styling() %>%
  column_spec(3, background = ht_fix_color[[1]]) %>%
  column_spec(4, background = ht_fix_color[[2]]) %>%
  column_spec(5, background = ht_fix_color[[3]]) %>%
  column_spec(14, background = ht_change_color[[1]]) %>%
  column_spec(15, background = ht_change_color[[2]])

```


```{r}
# Update datasets with new heights
d_l <- rows_update(d_l, new_ht, by = c("tree_id", "year"))
p_h <- filter(d_l, year > "init")
```

Our plot of height outliers doesn't change much, but if we include only status 1, unbroken trees, then our residuals are more homogenous. Filtering like this omits 836 observations over the 3 post harvest measurements. If we remove non-status-one and broken trees *under 12 m*, then 369 trees are omitted and most of the outliers are removed. 

Next, I'll look at the proportion of trees that have height measurements, but it is worth noting here that for regression purposes there are 3537 observations *with both dbh and height measurements* (of 4591 total). Of the observations with full measurements, filtering, as above, removes 304 and 82 observations, respectively.

```{r}
p_h %>% plot_ht(mag = 2.5)

# What trees are ommited if we remove broken trees
p_h %>%
  filter(
    !is.na(ht * dbh),
    status != 1 |
    get_cond(c(2, 3)) & ht < 12
  ) %>%
  select(dbh, ht) %>%
  points(col = "firebrick1", pch = 4)

p_h %>%
  filter(
    !is.na(ht * dbh),
    status != 1 | get_cond(c(2, 3))) %>%
  nrow()

p_h %>%
  filter(
    !is.na(ht * dbh),
    status != 1 | (get_cond(c(2, 3)) & ht < 12)) %>%
  nrow()
```

### Missing heights

Heights for 2018 seem to only have been taken for a sample of the trees (643 of 1505). I'm not sure how these were selected, so tree selection may be a source of bias. I checked what proportion of heights were measured for plots and treatments. 35 - 70% of heights were sampled for each treatment and 17% - 100% of each plot has height measurements.

For comparison purposes, I'll summarize height across measurement periods *only for tree ids that have height measurements in 2018*, with the understanding that the height related sampling error may introduce bias especially at the plot level, where sampling intensity ranged from 0.17 to 1.

```{r}
# do any target trees have missing heights? If so, how many
any(nrow(filter(d_l, status %in% c(1, 2, 3, 15, 16), is.na(ht))))
nrow(filter(d_l, status %in% c(1, 2, 3, 15, 16), is.na(ht)))

# proportion of (target) trees that have height measurements each period
filter(p_h, status %in% c(1, 2, 3, 15, 16)) %>%
  group_by(year, measured = !is.na(ht)) %>%
  summarise(n = n()) %>%
  mutate(freq = n / sum(n), .keep = "unused") %>%
  filter(measured)

# what proportion of trees in 2018 by treatment and plot DO have height data?
filter(d_l, status %in% c(1, 2, 3, 15, 16), year == "18") %>%
  group_by(plot, measured = !is.na(ht)) %>%
  summarise(n = n()) %>%
  mutate(freq = round(n / sum(n), 2)) %>%
  filter(measured) %>%
  select(plot, freq)

filter(d_l, status %in% c(1, 2, 3, 15, 16), year == "18") %>%
  group_by(treatment, measured = !is.na(ht)) %>%
  summarise(n = n()) %>%
  mutate(freq = round(n / sum(n), 2)) %>%
  filter(measured) %>%
  select(treatment, freq)


```

It looks like the 643, 2018 height observations are somewhat distributed across plots and treatments (although treatment L80 and plot C3 are underrepresented). Now, I want to check if heights were observed across dbh and height classes. Because trees are expected to grow from one year to the next, I will compare samples based on 2013 heights (90% of inventoried trees have heights in 2013). It appears as though the 2018 heights are relatively unbiased across the inventory. There still may be some bias within treatments, but we can burn that bridge later.

```{r compare-heights, echo = FALSE}
ht_18_id <- p_h %>% filter(year == "18" & !is.na(ht)) %>%
  pull(tree_id)

ht_18_13 <- p_h %>%
  filter(year == "13", !is.na(ht), tree_id %in% ht_18_id) %>%
  pull(ht)

ht_13_13 <- p_h %>%
  filter(year == "13", !is.na(ht)) %>%
  pull(ht)

ht_18_08 <- p_h %>%
  filter(year == "08", !is.na(ht), tree_id %in% ht_18_id) %>%
  pull(ht)

ht_08_08 <- p_h %>%
  filter(year == "08", !is.na(ht)) %>%
  pull(ht)

mycols <- palette.colors(palette = "Classic Tableau", alpha = .25)
hist(ht_13_13, col = mycols[1],
     ylim = c(0, 0.12),
     xlim = range(c(ht_13_13, ht_18_13)),
     prob = TRUE,
     main = "Sample distirbution comparison",
     xlab = "2013 heights (m)")
hist(ht_18_13, col = mycols[2], prob = TRUE, add = TRUE, breaks = 12)
legend(5, .1,
  legend = c("All 2013 heights", "2018 subset"),
  col = mycols[1:2],
  pch = 15,
  bty = "n",
  cex = 1.2,
  y.intersp = 1.7)
```

My plan is to calculate height metrics (for comparison) based just on those trees which have heights measured in 2018. This means that I would only be looking at 1911 of the 3488 total height measurements (status 1 trees only). 

There are 14 different trees which are missing heights for 2008 and have heights in 2013 and 2018. I can deal with these values in one of the following ways:

* Simply omit these observations from the analysis
* Manually estimate using average increments for species and treatment
* Fit a linear model including dbh, treatment, ht_13 and ht_18, bear.
* Fit separate models (mixed model?) 

```{r, include=FALSE}
d_l %>%
  group_by(tree_id) %>%
  filter(tree_id %in% ht_18_id, year == "08", status == 1, is.na(ht))
```

### Dominant trees missing heights

I need to check to see that there are heights recorded for all **dominant trees** at each observation period, otherwise we are not really getting dominant height. First I'll check to see how many heights are missing for dominant trees (top 4 dbh per plot == 50 tph). 

There are 12 plots that are missing dominant tree height data and all of them are in 2018---a total of 26 trees. It also looks like there are very few trees of the same species/plot to predict missing values from in some plots. I've included the average dbh of the missing tree as well as the range of dbh for which heights are available by plot/species. 

```{r, warning = FALSE}
p_h %>%
  group_by(plot, year) %>%
  filter(status == 1, !get_cond(c(2, 3))) %>%
  mutate(rank = rank(-dbh, ties.method = "min")) %>%
  group_by(plot, year, spp) %>%
  summarize(
    ht_na = sum(is.na(ht) & rank <= 4),
    na_dbh_mean = paste(
      mean(dbh[rank <= 4 & is.na(ht)], na.rm = TRUE), collapse = ", "),
    have_ht = sum(!is.na(ht)),
    have_dbh_range = paste(
      range(dbh[!is.na(ht)], na.rm = TRUE), collapse = ", ")
  ) %>%
  filter(ht_na > 0) %>%
  color_groups()
```

I'm curious about dominant trees in general, are they also the tallest trees? Out of the 240 dominant (diameter) trees over three measurement periods, 66 of them do not rank in the top 9 trees (by plot) in height. I'm excluding broken/dead tops and missing heights. This makes me wonder if we are accurately characterizing dominant trees. Perhaps these trees were once, but are no longer dominant.

```{r}
p_h %>%
  group_by(plot, year) %>%
  filter(status == 1, !get_cond(c(2, 3))) %>%
  mutate(
    tallest = rank(-ht, ties.method = "min"),
    widest = rank(-dbh, ties.method = "min")
  ) %>%
  filter(widest <= 4, tallest > 9, !is.na(ht)) %>%
  select(-c(azi, h_dist, treatment, cc, rot, status)) %>%
  group_by(tree_id) %>%
  color_groups()
```

## Defining live/dead trees

Status and condition codes provided do not necessarily define mortality, because a broken tree, depending on species may still be alive or dead. I'll define dead trees as:

1. snags or down snags (status -9 to -5, and 5 to 9)
2. trees broken below dbh and uprooted trees (status 30, 32)
3. any non-sprouting species broken above dbh (status 31)
4. any sprouting species broken below 3 meters


```{r define-live}

d_l <- d_l %>%
  mutate(
    live = case_when(
      status %in% c(5:9, -5:-9)                                  ~ FALSE,
      status %in% c(30, 32)                                      ~ FALSE,
      (spp %in% c("PSMEM", "PISI") & status == 31)               ~ FALSE,
      (spp %in% c("SESE3", "ALRU") & status == 31 & ht < 3)      ~ FALSE,
      (spp %in% c("SESE3", "ALRU") & status == 31 & lag(ht) < 3) ~ FALSE,
      TRUE                                                       ~ TRUE
    )
  )

# Do any trees go from being dead to being alive?
nrow(filter(group_by(d_l, tree_id), any(!live & lead(live))))

# update post-harvest data
p_h <- filter(d_l, year > "init")
```

## Define diameter increment

I looked at increment earlier to try to suss out bad dbh entries. Here I will formally add annual diameter increment to the long-form dataset. Each observation will be associated with a p1 and p2 increment. These are 5-year increments. Should I divide this number by 5?

```{r}
# Add increment data and update post-harvest data
d_l <- d_l %>%
  group_by(tree_id) %>%
  mutate(
    inc_1 = nth(lead(dbh) - dbh, 2, order_by = year),
    inc_2 = nth(lead(dbh) - dbh, 3, order_by = year)
  ) %>%
  ungroup()

p_h <- filter(d_l, year > "init")

```

## Explore bear damage

The first question is: how was old bear damage handled. To get an idea, I will look at trees that go from having bear damage to not having bear damage.

```{r, include=FALSE}
# Observations with recorded bear damage by year
d_l %>% filter(bear) %>% group_by(year) %>% summarize(n_bear = n())

# init     252   
# 08       185   
# 13       143   
# 18       172
# 

# 77 observations go from bear damage in 2008 to no bear damage in 2013
# this does not happen at all for 2013. Many of these in 2008 have notes that
# indicate old, or healed bear damage.
p_h %>%
  group_by(tree_id) %>%
  filter(bear & !lead(bear, order_by = year)) %>%
  color_groups("Trees that go from bear to no-bear")

# I'll look for notes that indicate old and healed bear damage (including one
# that "looks great"). There are 22 of these in 2008 and 46 in 2013.
p_h %>%
  group_by(tree_id) %>%
  filter(str_detect(tolower(notes), "old|healed|great")) %>%
  
  color_groups("Suspect notes for bear damage")

```


# Calculate summary statistics

I'm making the assumption now that all trees recorded as cut were alive in the initial conditions. For all of the following I use trees with status 1, 2, 3, 15, 16. Fifteen and 16 are cut trees, but in the long data format, they only occur on entries where year = "init" so they do not affected other periods. Status 1, 2 and 3 represent second-growth, advanced regen, and old-growth, respectively.

Generally, the `summarise()` command in each section defines the output of a given measure. The `mutate()` command is also used for calculating new columns. Calculations are done by grouping levels (generally by treatment, by year).

```{r}
# I'll store all my metrics in this list
measures <- list()
```

## Density

I'll look at a quick summary of quartiles of the number of tree observations by plot for each year. Initial plots had between 83 and 164 observations and subsequent years are roughly parallel. Density is being calculated for all live trees, including those broken above dbh.

```{r}

d_l %>%
  filter(status %in% c(1, 2, 3, 15, 16, 31)) %>%
  group_by(year, plot) %>%
  summarize(n = n()) %>%
  summarize(as_tibble_row(quantile(n)))



# unused <- function(data, by_species = FALSE) {
#   data %>%
#     filter(live | status %in% c(15, 16)) %>%
#     group_by(!!!group_vars(by_species)) %>%
#     # expansion factor 12.5, over 4 replicates
#     summarise(density = n() * 12.5 / 4, n_density = n())
# }


measures$density <- function(data, species) {
  if(is.null(species)) species <- unique(data$spp)
  data %>%
    filter(spp %in% species, live | status %in% c(15, 16)) %>%
    group_by(treatment, year, plot) %>%
    # expansion factor 12.5 (12.5 * .08 = 1 ha)
    summarise(density_plot = n() * 12.5, n_density = n()) %>%
    summarise(
      val_density = mean(density_plot),
      n_density = sum(n_density),
      sd_density = sd(density_plot)
    )
}
```

## Mortality

New mortality here is ascribed to observations of the current period which were alive in the previous period and are not alive in the current period and reported in tph. Currently, this is undefined for the first period ("init") and is zero for "08" (because "init" and "08" are really only one observation). The values for 2013 and 2018 record the new mortality in the previous period, ie: 08-13 and 13-18, respectively.

```{r}
measures$mort <- function(data, species) {
  if(is.null(species)) species <- unique(data$spp)
  data %>%
    filter(spp %in% species) %>%
    group_by(tree_id) %>%
    mutate(mort = ((live == FALSE) * (lag(live) == TRUE)) > 0) %>%
    group_by(year, treatment, plot) %>%
    summarize(mort_plot = sum(mort) * 12.5, n_mort = n()) %>%
    summarize(
      val_mort = mean(mort_plot),
      n_mort = sum(n_mort),
      sd_mort = sd(mort_plot)
    )
}
```

## dbh

Dbh will be calculated based on all live trees, including those broken above dbh and with broken and dead tops (most of these are SESE and assumed to be alive).

```{r}
measures$dbh <- function(data, species) {
  if(is.null(species)) species <- unique(data$spp)
  data %>%
    filter(spp %in% species, live | status %in% c(15, 16)) %>%
    group_by(treatment, year) %>%
    summarise(
      val_dbh = mean(dbh),
      n_dbh = n(),
      sd_dbh = sd(dbh, na.rm = TRUE)
    )
}


# unused <- d_l %>%
#   filter(status %in% c(1, 2, 3, 15, 16)) %>%
#   group_by(plot, year) %>%
#   slice_max(order_by = dbh, n = 4, with_ties = FALSE) %>%
#   group_by(spp, treatment, year) %>%
#   summarise(dom_dbh = mean(dbh), n_dom_dbh = n())

measures$dom_dbh <- function(data, species) {
  if(is.null(species)) species <- unique(data$spp)
  data %>%
    filter(live | status %in% c(15, 16)) %>%
    group_by(plot, year) %>%
    slice_max(order_by = dbh, n = 4, with_ties = FALSE) %>%
    filter(spp %in% species) %>%
    group_by(treatment, year) %>%
    summarise(
      val_dom_dbh = mean(dbh),
      n_dom_dbh = n(),
      sd_dom_dbh = sd(dbh))
}
```

## Heights

Heights will be determined using only trees with unbroken, live crowns.

Because there are about 14 observations in 2008 and 2013 that do not have height measurements, I am omitting these from analysis for now. Also, I am only looking at trees that have height measurements in 2018. This means that of the 3,538 total height observations, I am only looking at 1,929 over the the three measurement periods.

For dominant heights, I am using dominant dbh trees *not including broken and dead tops*. Not all of these have heights. For this reason, there are fewer than 4 trees per plot.

```{r}

# get ids of trees that have heights in 2018
ht_id_2018 <- filter(d_l, year == "18", !is.na(ht)) %>% pull(tree_id)

# average height I AM OMMITING MISSING HEIGHT MEASUREMENTS.
measures$ht <- function(data, species) {
  if(is.null(species)) species <- unique(data$spp)
  data %>%
    filter(
      spp %in% species,
      live | status %in% c(15, 16),
      !get_cond(c(2, 3)),
      tree_id %in% ht_id_2018,
      !is.na(ht)
    ) %>%
  group_by(treatment, year) %>%
  summarise(
    val_ht = mean(ht),
    n_ht = n(),
    sd_ht = sd(ht)
  )
}

# unused <- d_l %>%
#   filter(
#     live | status %in% c(15, 16),
#     !get_cond(c(2, 3)),
#     tree_id %in% ht_id_2018,
#     !is.na(ht)) %>%
#   group_by(spp, treatment, year) %>%
#   summarise(ht = mean(ht), n_ht = n())

# Dominant height
# I AM CALCULATING DOM HEIGHT ONLY FROM THOSE AVAILABLE
measures$dom_ht <- function(data, species) {
  if(is.null(species)) species <- unique(data$spp)
  data %>%
    filter(
      live | status %in% c(15, 16),
      !get_cond(2, 3),
      tree_id %in% ht_id_2018
    ) %>%
    group_by(plot, year) %>%
    slice_max(order_by = ht, n = 4, with_ties = FALSE) %>%
    filter(spp %in% species) %>%
    group_by(treatment, year) %>%
    summarise(
      val_dom_ht = mean(ht, na.rm = TRUE),
      n_dom_ht = sum(!is.na(ht)),
      sd_dom_ht = sd(ht, na.rm = TRUE)
    )
}

```


## Basal Area

Basal area, similar to density will be calculated for all live trees.

```{r}
# measures$ba <- d_l %>%
#   filter(live | status %in% c(15, 16)) %>%
#   group_by(treatment, year) %>%
#   summarise(ba = sum(dbh^2 * pi / 40000) * (12.5 / 4), n_ba = n())

measures$ba <- function(data, species) {
  if(is.null(species)) species <- unique(data$spp)
  data %>%
    filter(spp %in% species, live | status %in% c(15, 16)) %>%
    group_by(treatment, year, plot) %>%
    summarise(
      ba_plot = sum(dbh^2 * pi / 40000, na.rm = TRUE) * 12.5,
      n_ba = n()
    ) %>%
    summarize(
      val_ba = mean(ba_plot),
      n_ba = sum(n_ba),
      sd_ba = sd(ba_plot)
    )
}
```


## SDI

For SDI, I use the same trees that were used for basal area and density: all standing trees (broken or not) that are taller than breast height.

```{r}
# do any target trees have missing dbh?
any(nrow(filter(d_l, status %in% c(1, 2, 3, 15, 16), is.na(dbh))))

measures$sdi <- function(data, species) {
  if(is.null(species)) species <- unique(data$spp)
  data %>%
    filter(spp %in% species, live | status %in% c(15, 16)) %>%
    group_by(treatment, year, plot) %>%
    summarise(
      sdi_plot = sum(12.5 * (dbh * 0.04)^1.605, na.rm = TRUE),
      n_sdi = n()
    ) %>%
    summarize(
      val_sdi = mean(sdi_plot),
      n_sdi = sum(n_sdi),
      sd_sdi = sd(sdi_plot)
    )
}

```

# Initial summary tables

## All species
```{r, echo=FALSE}
# Call all summary functions with a given dataset and speces list
# and join the results into a wide dataframe.
get_measures <- function(data = d_l, species = NULL) {
  measures %>%
  map(exec, data, species) %>%
  reduce(full_join) %>%
  pivot_longer(
    !c(treatment, year),
    names_to = c(".value", "measure"),
    names_pattern = "(val|n|sd)_(.*)"
  )
}


# takes a long dataset of summary values
make_summary <- function(data) {
  data %>%
  arrange(measure, year) %>%
  relocate(measure) %>%
  mutate(across(where(is.double), ~ sprintf("%.1f", .x))) %>%
  mutate(val = paste0(val, " (", sd, ")")) %>%
  select(measure, treatment, year, val) %>%
  pivot_wider(names_from = treatment, values_from = val) %>%
  mutate(
    measure = recode(measure,
      density = "Density (tph)",
      mort = "New mortality (tph)",
      dbh = "dbh (cm)",
      dom_dbh = "Dominant dbh (cm)",
      ht = "Height (m)",
      dom_ht = "Dominant height (m)",
      ba = "Basal area (m^2^/ha)",
      sdi = "SDI"
    )
  )
}

```

```{r}

get_measures(d_l) %>%
  make_summary() %>%
  kbl() %>%
  kable_classic(full_width = FALSE, html_font = "Garamond") %>%
  add_header_above(c(" " = 2, "Treatment" = 5)) %>%
  collapse_rows(columns = 1, valign = "top")
```

## Redwood

```{r}
get_measures(species = "SESE3") %>%
  make_summary() %>%
  kbl() %>%
  kable_classic(full_width = FALSE, html_font = "Garamond") %>%
  add_header_above(c(" " = 2, "Treatment" = 5)) %>%
  collapse_rows(columns = 1, valign = "top")

```

## Douglas-fir

```{r}
get_measures(species = "PSMEM") %>%
  make_summary() %>%
  kbl() %>%
  kable_classic(full_width = FALSE, html_font = "Garamond") %>%
  add_header_above(c(" " = 2, "Treatment" = 5)) %>%
  collapse_rows(columns = 1, valign = "top")

```

# Figures

```{r, fig.height = 2, fig.width = 9.5, echo = FALSE, warning = FALSE}
fix_year <- function(year) {
  case_when(year == "init" ~2008,
            year == "08" ~2008.2,
            year == "13" ~2013,
            year == "18" ~2018)
}

plot_data <- bind_rows(
  tibble(spp = "SESE3", get_measures(species = "SESE3")),
  tibble(spp = "PSMEM", get_measures(species = "PSMEM"))
)

make_plot <- function(measure, data = plot_data) {
  yr_breaks <- c(2008, 2013, 2018)
  data %>%
    filter(measure == !!measure) %>%
    mutate(year = fix_year(year)) %>%
    ggplot(aes(year, val, color = spp)) +
      geom_line(position = position_dodge(width = .5)) +
      geom_point(position = position_dodge(width = .5)) +
      geom_errorbar(
        aes(ymin = val - sd, ymax = val + sd),
        width = .75,
        position = position_dodge(.5)
      ) +
      facet_wrap(~ treatment, ncol = 5) +
      scale_x_continuous(breaks = yr_breaks) +
      theme(panel.spacing.x = unit(1, "lines")) +
      scale_color_manual(values = c(SESE3 = "#F8766D", PSMEM = "#00BFC4")) +
      labs(y = measure)
}

for (var in names(measures)) {
  print(make_plot(var))
}
```